input:        "function a(b) { return 2*b }"
token stream: 'function' 'a' '(' 'b' ')' '{' 'return' '2' '*' 'b' '}'

 *  Bottom-up
 *  Pattern matching
   -> groups contains subgroups
 *  BNF?

 *  Identifiera literaler (€ värden)
 *  Identifiera syntaktiska regler som opererar på värden.
 *  ...
 *  Profit!


## LR parser
  *  stack = [ 0 ]




# $BOTTOM           ::=  number-literal | identifier
  number-literal    ::=  /-?\d+/
  identifier        ::=  /[A-Za-z_-]+\w*/

  expression        ::=  number-literal | identifier | operation | paren-expr
  operation         ::=  expression identifier expression
  paren-expr        ::=  "(" expression ")"

  'function' 'a' '(' 'b' ')' '{' 'return' '2' '*' 'b' '}'
  'function' {identifier:a} '(' {identifier:b} ')' '{' 'return' {literal:2} '*' {identifier:b} '}'
  'function' {identifier:a} {paren-expr: {identifier:b}} ')' '{' 'return' {*: {literal:2} {identifier:b}} '}'

 *  Identifiera bottom tokens
 *  Identifiera saker som involverar keywords, bottom tokens och circular refs
 *  Identifiera saker som involverar keywords, bottom tokens, circular refs och ^
 *  ... djupare och djupare

 *  'ignore' tokens -- tokens that are ignored by the parsing process, but left
    in the parse tree (how?), for instance whitespace.


## Strategy

$TOP               ::= top-statement
                     | top-statement $TOP

top-statement      ::= import-statement
                     | class-declaration

import-statement   ::= "import" package-name ";"

package-name       ::= identifier
                     | identifier "." package-name

class-declaration  ::= "class" identifier block

block              ::= "{" statements "}"

statements         ::= statement ";"
                     | statement ";" statements

statement          ::= ...
                     | expression

expression         ::= 
